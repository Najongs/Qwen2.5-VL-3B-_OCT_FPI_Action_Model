import os, time, json, cv2, zmq, numpy as np
import threading
from queue import Queue
from collections import defaultdict
from datetime import datetime
import struct # <-- Î°úÎ¥á Îç∞Ïù¥ÌÑ∞ Ïñ∏Ìå®ÌÇπ ÏúÑÌï¥ Ï∂îÍ∞Ä

# ==============================
# 1Ô∏è‚É£ ÏÑ∏ÏÖò Ìè¥Îçî ÏÉùÏÑ± (ÎèôÏùº)
# ==============================
session_time = datetime.now().strftime("%Y%m%d_%H%M%S")
BASE_DIR = f"./recv_all_{session_time}"
os.makedirs(BASE_DIR, exist_ok=True)
# ... (Ìè¥Îçî ÏÉùÏÑ± ÏΩîÎìú ÎèôÏùº) ...
print(f"üìÅ Save directory: {BASE_DIR}")
# Î°úÎ¥á Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÌååÏùº
ROBOT_CSV_PATH = os.path.join(BASE_DIR, f"robot_state_{session_time}.csv")

# ==============================
# 2Ô∏è‚É£ ÏÑ§Ï†ï Î∞è ÌååÎùºÎØ∏ÌÑ∞ (Î°úÎ¥á Í¥ÄÎ†® Ï∂îÍ∞Ä)
# ==============================
ZED_SERIAL_TO_VIEW = { # ... (ÎèôÏùº) ...
    "41182735": "View1", "49429257": "View2", "44377151": "View3", "49045152": "View4",
}
OAK_KEYWORD = "OAK"

# Î™®ÎãàÌÑ∞ÎßÅ ÏûÑÍ≥ÑÍ∞í (ÎèôÏùº)
STALL_SEC = 3.0
WARN_NET_MS = 150.0
WARN_TOTAL_MS = 1000.0 # Ïπ¥Î©îÎùº Ï¥ù ÏßÄÏó∞ Í∏∞Ï§Ä
STATUS_PERIOD = 1.0
FPS_PERIOD = 2.0

# --- [Î°úÎ¥á ZMQ ÏÑ§Ï†ï Ï∂îÍ∞Ä] ---
ZMQ_ROBOT_PUB_ADDRESS = "localhost" # ÎòêÎäî Î°úÎ¥á Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ IP
ZMQ_ROBOT_PUB_PORT = 5556
ZMQ_ROBOT_TOPIC = b"robot_state"
ROBOT_PAYLOAD_FORMAT = '<ddf12f' # ts, send_ts, force, 6x joints, 6x pose
ROBOT_PAYLOAD_SIZE = struct.calcsize(ROBOT_PAYLOAD_FORMAT) # 68 bytes

# --- [Ïπ¥Î©îÎùº ZMQ ÏÑ§Ï†ï] ---
ZMQ_CAM_PULL_PORT = 5555

# ==============================
# 3Ô∏è‚É£ ÎπÑÎèôÍ∏∞ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• (ÎèôÏùº)
# ==============================
class AsyncImageWriter(threading.Thread):
    # ... (ÏΩîÎìú Î≥ÄÍ≤Ω ÏóÜÏùå) ...
    def __init__(self, max_queue=5000):
        super().__init__(daemon=True)
        self.q = Queue(max_queue)
        self.stop_flag = threading.Event()

    def submit(self, path, img):
        if not self.stop_flag.is_set():
            try: self.q.put_nowait((path, img))
            except: print(f"[Writer] Queue full, dropping frame: {path}")

    def run(self):
        while True:
            try: path, img = self.q.get(timeout=0.1)
            except:
                if self.stop_flag.is_set() and self.q.empty(): break
                continue
            try: cv2.imwrite(path, img)
            except Exception as e: print(f"[Writer] Error saving {path}: {e}")

    def stop(self):
        print(f"üïí Flushing remaining {self.q.qsize()} images before shutdown...")
        self.stop_flag.set()
        while not self.q.empty(): time.sleep(0.1)
        print("üõë Writer thread stopped.")

# ==============================
# 4Ô∏è‚É£ ZMQ ÏàòÏã† ÏÑ§Ï†ï (ÏàòÏ†ïÎê® - ÏÜåÏºì 2Í∞ú + Poller)
# ==============================
ctx = zmq.Context.instance()

# Ïπ¥Î©îÎùº PULL ÏÜåÏºì
cam_sock = ctx.socket(zmq.PULL)
cam_sock.setsockopt(zmq.RCVHWM, 5000)
cam_sock.setsockopt(zmq.RCVBUF, 4 * 1024 * 1024)
cam_bind_addr = f"tcp://0.0.0.0:{ZMQ_CAM_PULL_PORT}"
cam_sock.bind(cam_bind_addr)
print(f"‚úÖ Camera PULL listening on {cam_bind_addr}")

# Î°úÎ¥á SUB ÏÜåÏºì
robot_sock = ctx.socket(zmq.SUB)
robot_sock.setsockopt(zmq.RCVHWM, 100) # Î°úÎ¥á ÏÉÅÌÉúÎäî ÏµúÏã†Ïù¥ Ï§ëÏöîÌïòÎØÄÎ°ú HWM ÎÇÆÍ≤å
robot_connect_addr = f"tcp://{ZMQ_ROBOT_PUB_ADDRESS}:{ZMQ_ROBOT_PUB_PORT}"
robot_sock.connect(robot_connect_addr)
robot_sock.subscribe(ZMQ_ROBOT_TOPIC) # ÌäπÏ†ï ÌÜ†ÌîΩÎßå Íµ¨ÎèÖ
print(f"‚úÖ Robot SUB connected to {robot_connect_addr} (Topic: '{ZMQ_ROBOT_TOPIC.decode()}')")

# Poller ÏÉùÏÑ± Î∞è Îì±Î°ù
poller = zmq.Poller()
poller.register(cam_sock, zmq.POLLIN)
poller.register(robot_sock, zmq.POLLIN)

writer = AsyncImageWriter()
writer.start()

# ==============================
# 5Ô∏è‚É£ ÏÉÅÌÉú Î≥ÄÏàò (Î°úÎ¥á Í¥ÄÎ†® Ï∂îÍ∞Ä)
# ==============================
# Ïπ¥Î©îÎùº ÏÉÅÌÉú
cam_cnt = defaultdict(int)
cam_fail_count = defaultdict(int)
cam_last_ts = {}
cam_delta_dict = {}
cam_latest_recv = {}
cam_last_recv_wall = {}
cam_save_dir_cache = {}

# Î°úÎ¥á ÏÉÅÌÉú
robot_cnt = 0
robot_latest_state = {}
robot_last_recv_wall = 0.0
robot_data_buffer = [] # CSV Ï†ÄÏû•ÏùÑ ÏúÑÌïú ÏûÑÏãú Î≤ÑÌçº

t0 = time.time()
last_status_print = time.time()
last_fps_print = time.time()

# ==============================
# 6Ô∏è‚É£ Ïú†Ìã∏: Ïπ¥Î©îÎùºÎ≥Ñ ÎîîÎ†âÌÜ†Î¶¨ Ï∫êÏãú (ÎèôÏùº)
# ==============================
def get_save_dir_for_cam(cam_name: str):
    # ... (ÏΩîÎìú Î≥ÄÍ≤Ω ÏóÜÏùå) ...
    if cam_name in cam_save_dir_cache: return cam_save_dir_cache[cam_name]
    cam_lower = cam_name.lower()
    view_dir = os.path.join(BASE_DIR, "Unknown")
    if "zed" in cam_lower:
        for serial, view_name in ZED_SERIAL_TO_VIEW.items():
            if serial in cam_lower: view_dir = os.path.join(BASE_DIR, view_name); break
    elif OAK_KEYWORD.lower() in cam_lower: view_dir = os.path.join(BASE_DIR, "View5")
    if "left" in cam_lower: save_dir = os.path.join(view_dir, "left")
    elif "right" in cam_lower: save_dir = os.path.join(view_dir, "right")
    else: save_dir = view_dir
    os.makedirs(save_dir, exist_ok=True)
    cam_save_dir_cache[cam_name] = save_dir
    return save_dir

# --- [Î°úÎ¥á Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ìï®Ïàò Ï∂îÍ∞Ä] ---
def save_robot_data_to_csv(data_list, filepath):
    """Î°úÎ¥á ÏÉÅÌÉú Îç∞Ïù¥ÌÑ∞Î•º CSV ÌååÏùºÏóê Ï∂îÍ∞ÄÌï©ÎãàÎã§."""
    is_new_file = not os.path.exists(filepath)
    try:
        with open(filepath, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            if is_new_file:
                 writer.writerow([
                    "recv_timestamp", # Î°úÏª¨ ÏàòÏã† ÏãúÍ∞Ñ
                    "origin_timestamp", # ÏÜ°Ïã†Ï∏° clock.now()
                    "send_timestamp",   # ÏÜ°Ïã†Ï∏° time.time()
                    "force_placeholder",
                    "joint_1", "joint_2", "joint_3", "joint_4", "joint_5", "joint_6",
                    "pose_x", "pose_y", "pose_z", "pose_a", "pose_b", "pose_r"
                 ])
            writer.writerows(data_list)
        # print(f"üíæ Saved {len(data_list)} robot states to {filepath}")
    except Exception as e:
        print(f"[ERROR] Failed to save robot data to CSV: {e}")


# ==============================
# 7Ô∏è‚É£ ÏàòÏã† Î£®ÌîÑ (ÏàòÏ†ïÎê® - Poller ÏÇ¨Ïö©)
# ==============================
try:
    while True:
        try:
            # PollerÎ°ú Ïù¥Î≤§Ìä∏ ÎåÄÍ∏∞ (100ms ÌÉÄÏûÑÏïÑÏõÉ)
            socks = dict(poller.poll(timeout=100))
        except KeyboardInterrupt:
            break # Ctrl+C Í∞êÏßÄ Ïãú Î£®ÌîÑ Ï¢ÖÎ£å
        except Exception as e:
            print(f"[WARN] poller.poll error: {e}")
            time.sleep(0.1)
            continue

        now_wall = time.time() # ÌòÑÏû¨ ÏãúÍ∞Ñ (Ïó¨Îü¨ Î≤à ÏÇ¨Ïö©Îê®)

        # --- Ïπ¥Î©îÎùº ÏÜåÏºì Ï≤òÎ¶¨ ---
        if cam_sock in socks and socks[cam_sock] == zmq.POLLIN:
            try:
                # DONTWAIT ÏÇ¨Ïö©: poll()Ïù¥ Îç∞Ïù¥ÌÑ∞ ÏûàÏùåÏùÑ Î≥¥Ïû•
                parts = cam_sock.recv_multipart(zmq.DONTWAIT)

                if len(parts) < 2: print("[WARN] Cam multipart length < 2, skip"); continue
                meta_raw, jpg = parts[0], parts[1]
                if not jpg or len(jpg) < 5000: print(f"[WARN] Incomplete JPEG (len={len(jpg)})"); continue

                try: meta = json.loads(meta_raw.decode("utf-8"))
                except Exception as e: print(f"[WARN] Cam meta decode error: {e}"); continue

        cam = meta.get("camera", "unknown")
        ts = float(meta.get("timestamp", 0.0))
        send_time = float(meta.get("send_time", 0.0))
        recv_time = time.time()

        # ‚ú®‚ú®‚ú® ÌïµÏã¨ ÏàòÏ†ï Î∂ÄÎ∂Ñ: Ìï∏ÎìúÏÖ∞Ïù¥ÌÅ¨ Ìå®ÌÇ∑ (ts=0.0) Í±¥ÎÑàÎõ∞Í∏∞ ‚ú®‚ú®‚ú®
        if ts == 0.0:
             print(f"‚ö™Ô∏è Received non-data message (ts=0.0) from {cam}, skipping.")
             continue # Îã§Ïùå Î©îÏãúÏßÄ ÏàòÏã†ÏúºÎ°ú ÎÑòÏñ¥Í∞ê
        # ‚ú®‚ú®‚ú® ÏàòÏ†ï ÏôÑÎ£å ‚ú®‚ú®‚ú®

                net_delay = (now_wall - send_time) if send_time > 0 else 0.0
                total_delay = (now_wall - ts) if ts > 0 else 0.0

                img = cv2.imdecode(np.frombuffer(jpg, np.uint8), cv2.IMREAD_COLOR)
                if img is None:
                    cam_fail_count[cam] += 1
                    print(f"[WARN] Cam JPEG decode failed for {cam} (fail #{cam_fail_count[cam]})")
                    continue

                cam_cnt[cam] += 1
                cam_latest_recv[cam] = {
                    "capture_time": ts, "send_time": send_time, "recv_time": now_wall,
                    "net_delay": net_delay, "total_delay": total_delay
                }
                cam_last_recv_wall[cam] = now_wall

                if cam in cam_last_ts and ts > 0:
                    delta = ts - cam_last_ts[cam]
                    if delta > 0: cam_delta_dict[cam] = delta
                if ts > 0: cam_last_ts[cam] = ts

                save_dir = get_save_dir_for_cam(cam)
                filename = f"{cam}_{ts:.3f}.jpg" if ts > 0 else f"{cam}_{now_wall:.3f}.jpg"
                writer.submit(os.path.join(save_dir, filename), img)

            except zmq.Again: # Ïù¥Î°†ÏÉÅ Î∞úÏÉù Ïïà Ìï® (poll ÌõÑ DONTWAIT)
                pass
            except Exception as e:
                 print(f"[ERROR] Unhandled exception during camera processing: {e}")


        # --- Î°úÎ¥á ÏÜåÏºì Ï≤òÎ¶¨ ---
        if robot_sock in socks and socks[robot_sock] == zmq.POLLIN:
            try:
                # DONTWAIT ÏÇ¨Ïö©
                parts = robot_sock.recv_multipart(zmq.DONTWAIT)

                if len(parts) != 2: print(f"[WARN] Robot multipart length != 2 (got {len(parts)}), skip"); continue
                topic, payload = parts[0], parts[1]

                if topic != ZMQ_ROBOT_TOPIC: print(f"[WARN] Unexpected robot topic: {topic}"); continue
                if len(payload) != ROBOT_PAYLOAD_SIZE:
                    print(f"[WARN] Robot payload size mismatch! Expected {ROBOT_PAYLOAD_SIZE}, got {len(payload)}")
                    continue

                try:
                    # Îç∞Ïù¥ÌÑ∞ Ïñ∏Ìå®ÌÇπ
                    unpacked_data = struct.unpack(ROBOT_PAYLOAD_FORMAT, payload)
                    origin_ts = unpacked_data[0]
                    send_ts = unpacked_data[1]
                    force_pl = unpacked_data[2]
                    joints = unpacked_data[3:9]
                    pose = unpacked_data[9:15]

                    robot_cnt += 1
                    robot_latest_state = {
                        "recv_time": now_wall,
                        "origin_ts": origin_ts,
                        "send_ts": send_ts,
                        "joints": joints,
                        "pose": pose,
                        "net_delay": now_wall - send_ts,
                        "total_delay": now_wall - origin_ts,
                    }
                    robot_last_recv_wall = now_wall
                    # CSV Ï†ÄÏû•ÏùÑ ÏúÑÌï¥ Î≤ÑÌçºÏóê Ï∂îÍ∞Ä (Î¶¨Ïä§Ìä∏ ÌòïÌÉúÎ°ú)
                    robot_data_buffer.append([now_wall] + list(unpacked_data))

                except struct.error as e:
                    print(f"[WARN] Robot payload unpack error: {e}")
                    continue

            except zmq.Again:
                pass
            except Exception as e:
                 print(f"[ERROR] Unhandled exception during robot processing: {e}")


        # ==========================
        # Ïã§ÏãúÍ∞Ñ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ (ÏàòÏ†ïÎê®)
        # ==========================
        if now_wall - last_status_print >= STATUS_PERIOD:
            print(f"\n--- Status Update ({datetime.now().strftime('%H:%M:%S')}) ---")
            # Ïπ¥Î©îÎùº ÏÉÅÌÉú Ï∂úÎ†•
            print("üì∑ Cameras:")
            for k in sorted(cam_latest_recv.keys()):
                data = cam_latest_recv[k]
                d = cam_delta_dict.get(k, 0.0)
                fps = (1.0 / d) if d > 0 else 0.0
                net_ms = data['net_delay'] * 1000.0
                total_ms = data['total_delay'] * 1000.0
                net_flag = "‚ö†Ô∏è" if net_ms > WARN_NET_MS else " "
                total_flag = "‚ö†Ô∏è" if total_ms > WARN_TOTAL_MS else " "
                stall_mark = " ‚õîSTALLED" if (now_wall - cam_last_recv_wall.get(k, 0.0)) >= STALL_SEC else ""
                fail_mark = f" (fail:{cam_fail_count.get(k,0)})" if cam_fail_count.get(k,0) > 0 else ""
                print(
                    f"  {k:<25} | "
                    f"cap:{data['capture_time']:.3f} | send:{data['send_time']:.3f} | recv:{data['recv_time']:.3f} | "
                    f"Œînet:{net_ms:6.1f}ms{net_flag} | Œîtotal:{total_ms:6.1f}ms{total_flag} | "
                    f"{fps:5.2f}fps{stall_mark}{fail_mark}"
                )
            # Î°úÎ¥á ÏÉÅÌÉú Ï∂úÎ†•
            print("ü§ñ Robot:")
            if robot_latest_state:
                 r_data = robot_latest_state
                 r_net_ms = r_data['net_delay'] * 1000.0
                 r_total_ms = r_data['total_delay'] * 1000.0
                 r_net_flag = "‚ö†Ô∏è" if r_net_ms > WARN_NET_MS else " "
                 # Î°úÎ¥áÏùÄ clock Ïò§Ï∞®Í∞Ä ÏûàÏúºÎØÄÎ°ú total delay Í≤ΩÍ≥†Îäî Ï∞∏Í≥†Ïö©
                 r_total_flag = "‚ùì" if abs(r_total_ms) > WARN_TOTAL_MS else " "
                 r_stall_mark = " ‚õîSTALLED" if (now_wall - robot_last_recv_wall) >= STALL_SEC else ""
                 print(
                    f"  {'Robot State':<25} | "
                    f"ori:{r_data['origin_ts']:.3f} | send:{r_data['send_ts']:.3f} | recv:{r_data['recv_time']:.3f} | "
                    f"Œînet:{r_net_ms:6.1f}ms{r_net_flag} | Œîtotal:{r_total_ms:6.1f}ms{r_total_flag} | "
                    f"J1:{r_data['joints'][0]:<6.1f} Px:{r_data['pose'][0]:<7.1f}{r_stall_mark}"
                 )
            else:
                 print("  Waiting for robot data...")

            # Writer Queue Status
            print(f"üíæ Writer Queue: {writer.q.qsize()}")
            last_status_print = now_wall

        # ==========================
        # ÌèâÍ∑† FPS Ï∂úÎ†• (Ïπ¥Î©îÎùºÎßå)
        # ==========================
        if now_wall - last_fps_print >= FPS_PERIOD:
            elapsed = now_wall - last_fps_print
            line = " | ".join([f"{k}:{cam_cnt[k]/elapsed:.1f}fps" for k in sorted(cam_cnt)])
            print("üìä Camera Avg:", line)
            cam_cnt = defaultdict(int) # Reset camera count only
            last_fps_print = now_wall

        # ==========================
        # Î°úÎ¥á Îç∞Ïù¥ÌÑ∞ Ï£ºÍ∏∞Ï†Å Ï†ÄÏû• (Ïòà: 1000Í∞ú Î™®Ïù¥Î©¥ Ï†ÄÏû•)
        # ==========================
        if now - last_fps_print >= FPS_PERIOD:
            elapsed = now - last_fps_print
            if elapsed > 0: # Prevent division by zero if loop runs extremely fast
                line = " | ".join([f"{k}:{cnt[k]/elapsed:.1f}fps" for k in sorted(cnt)])
                print("üìä ÌèâÍ∑†:", line)
            cnt = defaultdict(int)
            last_fps_print = now

except KeyboardInterrupt:
    print("\nüõë Interrupted by user.")

finally:
    print("\n--- Final Summary & Cleanup ---")
    # ÏµúÏ¢Ö Î°úÎ¥á Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    if robot_data_buffer:
        print(f"üíæ Saving remaining {len(robot_data_buffer)} robot states...")
        save_robot_data_to_csv(list(robot_data_buffer), ROBOT_CSV_PATH)

    # Ïπ¥Î©îÎùº ÏöîÏïΩ (ÎèôÏùº)
    print("\nüì∑ Final Camera Summary:")
    for k in sorted(cam_latest_recv.keys()):
        data = cam_latest_recv[k]; print(f"  {k:<25} | cap_last:{data['capture_time']:.3f} | send_last:{data['send_time']:.3f} | recv_last:{data['recv_time']:.3f} | fail:{cam_fail_count.get(k,0)}")

    # Î°úÎ¥á ÏµúÏ¢Ö ÏÉÅÌÉú
    print("\nü§ñ Final Robot State:")
    if robot_latest_state: r_data = robot_latest_state; print(f"  ori:{r_data['origin_ts']:.3f} | send:{r_data['send_ts']:.3f} | recv:{r_data['recv_time']:.3f} | J1:{r_data['joints'][0]:.1f} | Px:{r_data['pose'][0]:.1f}")
    else: print("  No robot data received.")

    # Ï¢ÖÎ£å Ï≤òÎ¶¨
    writer.stop()
    writer.join()
    poller.unregister(cam_sock)
    poller.unregister(robot_sock)
    cam_sock.close()
    robot_sock.close()
    ctx.term()
    print("‚úÖ Receiver shutdown complete.")